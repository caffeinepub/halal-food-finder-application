{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Stabilize geolocation tracking UX and restore resilient visit counter display",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Prevent competing location flows, throttle watch-driven searches, reduce toast noise, and recover cleanly from transient tracking errors.",
      "acceptanceCriteria": [
        "When continuous tracking is active, the one-time location detection flow cannot run concurrently (UI prevents it or stopping tracking is required first).",
        "Continuous tracking updates do not trigger repeated searches more often than the configured minimum interval, even if the device reports frequent small position changes.",
        "While tracking, the app does not show a success toast for every update; toasts occur only for start/stop and meaningful state transitions (e.g., first fix, errors).",
        "If the browser reports transient watch errors (TIMEOUT/POSITION_UNAVAILABLE), the UI reflects the error and the user can stop and restart tracking without needing a full page refresh."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/SearchSection.tsx",
          "operation": "modify",
          "description": "Gate the one-time “Detect My Location” flow while continuous tracking is active (disable and/or require stopping tracking first) to prevent concurrent workflows. Add minimum time-interval throttling for watchPosition-triggered searches (in addition to the existing significant-change check) and remove per-update success toasts; only toast on start/stop and meaningful state transitions (e.g., first fix acquired, permission denied, tracking errors). Ensure UI state properly reflects transient tracking errors without leaving detection/tracking stuck in an in-flight state."
        },
        {
          "path": "frontend/src/hooks/useGeolocationWatch.ts",
          "operation": "modify",
          "description": "Harden continuous tracking state management to recover from transient watch errors (TIMEOUT/POSITION_UNAVAILABLE): ensure status transitions and error state do not leave the hook in an in-flight/starting state, and allow stop/restart sequences to function reliably. Add/adjust returned state needed by the UI to toast only on meaningful transitions (e.g., expose a first-fix indicator or transition-friendly status fields)."
        },
        {
          "path": "frontend/src/lib/rateLimit.ts",
          "operation": "create",
          "description": "Add a small utility to enforce a minimum interval between repeated actions (time-based rate limiting) suitable for watchPosition-driven search triggers; use it from SearchSection to prevent overly frequent searches due to coordinate jitter."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Always display the visit counter row with an English fallback, and add a lightweight frontend retry so counter failures do not hide the counter for the session.",
      "acceptanceCriteria": [
        "The footer always shows a “Total visits:” label; when the counter cannot be retrieved it displays an English fallback value (e.g., “unavailable”) instead of hiding the row.",
        "A transient failure to call the backend counter methods triggers an automatic retry at least once, without blocking the main UI.",
        "Counter failures do not crash the app and do not prevent searching/browsing results."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/Footer.tsx",
          "operation": "modify",
          "description": "Always render a “Total visits:” row in the footer. When loading, show a non-blocking loading message; when an error occurs, show an English fallback value such as “unavailable” (do not hide the row based on counterError)."
        },
        {
          "path": "frontend/src/hooks/useTrafficCounter.ts",
          "operation": "modify",
          "description": "Add a lightweight retry strategy for increment/get (at least one automatic retry after a short delay) and keep failures non-fatal (no thrown errors). Ensure the hook settles loading state even when calls fail so the footer can render the fallback text and the rest of the app remains functional."
        }
      ]
    }
  ]
}